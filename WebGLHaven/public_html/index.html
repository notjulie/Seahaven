<!DOCTYPE html>
<html>
   <head>
      <link rel="stylesheet" href="style.css" type="text/css"/>

      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
      <title>WebGLHaven</title>
   </head>

   <body id="body">
      <canvas id="c"></canvas>
      <div id="buttonBar">
         <button id="newGame" onclick="stateMachine.newGame()">New Game</button>
      </div>

      <!-- beautiful three.js -->
      <script type="text/javascript" src="three/three.js"></script>
      <script src="three/GLTFLoader.js"></script>

      <!-- WebHaven js includes -->
      <script type="text/javascript" src="Card3D.js"></script>
      <script type="text/javascript" src="CardID.js"></script>
      <script type="text/javascript" src="CardLocations.js"></script>
      <script type="text/javascript" src="DeckOfCards.js"></script>
      <script type="text/javascript" src="LocationID.js"></script>
      <script type="text/javascript" src="Renderer.js"></script>
      <script type="text/javascript" src="Shapes.js"></script>
      <script type="text/javascript" src="Tower3D.js"></script>
      <script type="text/javascript" src="World.js"></script>

      <!-- WebHaven StateMachine js includes -->
      <script type="text/javascript" src="StateMachine/StateMachine.js"></script>
      <script type="text/javascript" src="StateMachine/State.js"></script>
      <script type="text/javascript" src="StateMachine/GameIdleState.js"></script>
      <script type="text/javascript" src="StateMachine/MoveToAcesState.js"></script>
      <script type="text/javascript" src="StateMachine/NewGameState.js"></script>
      
      <!-- Three.js WebGL main rendering loop -->
      <script type="text/javascript">
         // create our globals
         var world = new World();
         var stateMachine = new StateMachine();
         var deckOfCards = new DeckOfCards({
            width: world.getCardWidth(),
            height: world.getCardHeight(),
            cornerRadius: world.getCardWidth() / 10,
            rankHeight: (0.13 / 0.43) * world.getCardWidth()
         });


         var cardLocations = new CardLocations();

         function resizeCanvas() {
            renderer.resizeCanvas(body.clientWidth, body.clientHeight);
         }

         function main() {

            // create our renderer
            const canvas = document.querySelector('#c');
            var renderer = new Renderer(canvas);
            var scene = renderer.getScene();

            // add our handler to resize it
            body.onresize = function () {
               renderer.resizeCanvas(body.clientWidth, body.clientHeight);
            };
            body.onresize();

            var texture = new THREE.TextureLoader().load('Sand 002_COLOR.jpg');
            texture.repeat.x = 5000;
            texture.repeat.y = 5000;
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            var material = new THREE.MeshBasicMaterial( { map: texture } );
            var groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            groundGeometry.rotateX(-90 * Math.PI / 180);
            //var ground = new THREE.Mesh(groundGeometry, new THREE.MeshMatcapMaterial({color: 0x7f4f00}));
            var ground = new THREE.Mesh(groundGeometry, material);
            ground.position.y = world.getGroundY();
            scene.add(ground);

            var tableTexture = new THREE.TextureLoader().load('grass.jpg');
            tableTexture.repeat.x = 10;
            tableTexture.repeat.y = 10;
            tableTexture.wrapS = tableTexture.wrapT = THREE.RepeatWrapping;
            var tableMaterial = new THREE.MeshBasicMaterial( { map: tableTexture } );
            var tableWorldGeometry = world.getTableGeometry();
            var tableWorldSize = tableWorldGeometry.getSize(new THREE.Vector3());
            var tableGeometry = new THREE.PlaneGeometry(
                    tableWorldSize.x,
                    Math.sqrt(tableWorldSize.y * tableWorldSize.y + tableWorldSize.z * tableWorldSize.z)
                    );
            tableGeometry.computeBoundingBox();
            tableGeometry.translate(0, -tableGeometry.boundingBox.min.y, 0);
            tableGeometry.rotateX(-Math.atan2(tableWorldSize.z, tableWorldSize.y));
            var table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.y = tableWorldGeometry.min.y;
            table.position.z = tableWorldGeometry.max.z;
            scene.add(table);


            // initialize our deck of cards; on completion add cards to the scene
            deckOfCards.initialize(function () {
               // add all the cards to the scene, but hidden
               for (var cardID in CardID.info) {
                  var card3D = deckOfCards.getCard3D(cardID);
                  card3D.visible = false;
                  scene.add(card3D);
               }
               
               // start a new game
               stateMachine.setState(new NewGameState());
            });


            var towers = new Array();
            var loader = new THREE.GLTFLoader();

            for (var i = 0; i < 4; ++i) {
               towers[i] = new Tower3D();
               var position = world.getTowerPosition(i);
               towers[i].position.x = position.x;
               towers[i].position.y = position.y;
               towers[i].position.z = position.z;
               towers[i].scale.y = position.height;
               scene.add(towers[i]);
            }

            renderer.start();

         }

         main();
      </script>
   </body>
</html>
